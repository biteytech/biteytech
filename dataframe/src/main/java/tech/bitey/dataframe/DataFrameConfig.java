package tech.bitey.dataframe;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.NoSuchElementException;

import org.joda.beans.ImmutableBean;
import org.joda.beans.JodaBeanUtils;
import org.joda.beans.MetaBean;
import org.joda.beans.MetaProperty;
import org.joda.beans.TypedMetaBean;
import org.joda.beans.gen.BeanDefinition;
import org.joda.beans.gen.PropertyDefinition;
import org.joda.beans.impl.direct.DirectFieldsBeanBuilder;
import org.joda.beans.impl.direct.MinimalMetaBean;

@BeanDefinition(style = "minimal")
public final class DataFrameConfig implements ImmutableBean {

    @PropertyDefinition(validate = "notEmpty")
    private final List<Column<?>> columns;

    @PropertyDefinition(validate = "notEmpty")
    private final List<String> columnNames;

    @PropertyDefinition
    private final String keyColumnName;

    public DataFrame create() {
        return DataFrameFactory.create(columns, columnNames, keyColumnName);
    }

    //------------------------- AUTOGENERATED START -------------------------
    /**
     * The meta-bean for {@code DataFrameConfig}.
     */
    private static final TypedMetaBean<DataFrameConfig> META_BEAN =
            MinimalMetaBean.of(
                    DataFrameConfig.class,
                    new String[] {
                            "columns",
                            "columnNames",
                            "keyColumnName"},
                    () -> new DataFrameConfig.Builder(),
                    b -> b.getColumns(),
                    b -> b.getColumnNames(),
                    b -> b.getKeyColumnName());

    /**
     * The meta-bean for {@code DataFrameConfig}.
     * @return the meta-bean, not null
     */
    public static TypedMetaBean<DataFrameConfig> meta() {
        return META_BEAN;
    }

    static {
        MetaBean.register(META_BEAN);
    }

    /**
     * Returns a builder used to create an instance of the bean.
     * @return the builder, not null
     */
    public static DataFrameConfig.Builder builder() {
        return new DataFrameConfig.Builder();
    }

    private DataFrameConfig(
            List<Column<?>> columns,
            List<String> columnNames,
            String keyColumnName) {
        JodaBeanUtils.notEmpty(columns, "columns");
        JodaBeanUtils.notEmpty(columnNames, "columnNames");
        this.columns = Collections.unmodifiableList(new ArrayList<>(columns));
        this.columnNames = Collections.unmodifiableList(new ArrayList<>(columnNames));
        this.keyColumnName = keyColumnName;
    }

    @Override
    public TypedMetaBean<DataFrameConfig> metaBean() {
        return META_BEAN;
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the columns.
     * @return the value of the property, not empty
     */
    public List<Column<?>> getColumns() {
        return columns;
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the columnNames.
     * @return the value of the property, not empty
     */
    public List<String> getColumnNames() {
        return columnNames;
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the keyColumnName.
     * @return the value of the property
     */
    public String getKeyColumnName() {
        return keyColumnName;
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a builder that allows this bean to be mutated.
     * @return the mutable builder, not null
     */
    public Builder toBuilder() {
        return new Builder(this);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj != null && obj.getClass() == this.getClass()) {
            DataFrameConfig other = (DataFrameConfig) obj;
            return JodaBeanUtils.equal(columns, other.columns) &&
                    JodaBeanUtils.equal(columnNames, other.columnNames) &&
                    JodaBeanUtils.equal(keyColumnName, other.keyColumnName);
        }
        return false;
    }

    @Override
    public int hashCode() {
        int hash = getClass().hashCode();
        hash = hash * 31 + JodaBeanUtils.hashCode(columns);
        hash = hash * 31 + JodaBeanUtils.hashCode(columnNames);
        hash = hash * 31 + JodaBeanUtils.hashCode(keyColumnName);
        return hash;
    }

    @Override
    public String toString() {
        StringBuilder buf = new StringBuilder(128);
        buf.append("DataFrameConfig{");
        buf.append("columns").append('=').append(columns).append(',').append(' ');
        buf.append("columnNames").append('=').append(columnNames).append(',').append(' ');
        buf.append("keyColumnName").append('=').append(JodaBeanUtils.toString(keyColumnName));
        buf.append('}');
        return buf.toString();
    }

    //-----------------------------------------------------------------------
    /**
     * The bean-builder for {@code DataFrameConfig}.
     */
    public static final class Builder extends DirectFieldsBeanBuilder<DataFrameConfig> {

        private List<Column<?>> columns = Collections.emptyList();
        private List<String> columnNames = Collections.emptyList();
        private String keyColumnName;

        /**
         * Restricted constructor.
         */
        private Builder() {
        }

        /**
         * Restricted copy constructor.
         * @param beanToCopy  the bean to copy from, not null
         */
        private Builder(DataFrameConfig beanToCopy) {
            this.columns = new ArrayList<>(beanToCopy.getColumns());
            this.columnNames = new ArrayList<>(beanToCopy.getColumnNames());
            this.keyColumnName = beanToCopy.getKeyColumnName();
        }

        //-----------------------------------------------------------------------
        @Override
        public Object get(String propertyName) {
            switch (propertyName.hashCode()) {
                case 949721053:  // columns
                    return columns;
                case -851002990:  // columnNames
                    return columnNames;
                case 323122880:  // keyColumnName
                    return keyColumnName;
                default:
                    throw new NoSuchElementException("Unknown property: " + propertyName);
            }
        }

        @SuppressWarnings("unchecked")
        @Override
        public Builder set(String propertyName, Object newValue) {
            switch (propertyName.hashCode()) {
                case 949721053:  // columns
                    this.columns = (List<Column<?>>) newValue;
                    break;
                case -851002990:  // columnNames
                    this.columnNames = (List<String>) newValue;
                    break;
                case 323122880:  // keyColumnName
                    this.keyColumnName = (String) newValue;
                    break;
                default:
                    throw new NoSuchElementException("Unknown property: " + propertyName);
            }
            return this;
        }

        @Override
        public Builder set(MetaProperty<?> property, Object value) {
            super.set(property, value);
            return this;
        }

        @Override
        public DataFrameConfig build() {
            return new DataFrameConfig(
                    columns,
                    columnNames,
                    keyColumnName);
        }

        //-----------------------------------------------------------------------
        /**
         * Sets the columns.
         * @param columns  the new value, not empty
         * @return this, for chaining, not null
         */
        public Builder columns(List<Column<?>> columns) {
            JodaBeanUtils.notEmpty(columns, "columns");
            this.columns = columns;
            return this;
        }

        /**
         * Sets the {@code columns} property in the builder
         * from an array of objects.
         * @param columns  the new value, not empty
         * @return this, for chaining, not null
         */
        @SafeVarargs
        public final Builder columns(Column<?>... columns) {
            return columns(Arrays.asList(columns));
        }

        /**
         * Sets the columnNames.
         * @param columnNames  the new value, not empty
         * @return this, for chaining, not null
         */
        public Builder columnNames(List<String> columnNames) {
            JodaBeanUtils.notEmpty(columnNames, "columnNames");
            this.columnNames = columnNames;
            return this;
        }

        /**
         * Sets the {@code columnNames} property in the builder
         * from an array of objects.
         * @param columnNames  the new value, not empty
         * @return this, for chaining, not null
         */
        public Builder columnNames(String... columnNames) {
            return columnNames(Arrays.asList(columnNames));
        }

        /**
         * Sets the keyColumnName.
         * @param keyColumnName  the new value
         * @return this, for chaining, not null
         */
        public Builder keyColumnName(String keyColumnName) {
            this.keyColumnName = keyColumnName;
            return this;
        }

        //-----------------------------------------------------------------------
        @Override
        public String toString() {
            StringBuilder buf = new StringBuilder(128);
            buf.append("DataFrameConfig.Builder{");
            buf.append("columns").append('=').append(JodaBeanUtils.toString(columns)).append(',').append(' ');
            buf.append("columnNames").append('=').append(JodaBeanUtils.toString(columnNames)).append(',').append(' ');
            buf.append("keyColumnName").append('=').append(JodaBeanUtils.toString(keyColumnName));
            buf.append('}');
            return buf.toString();
        }

    }

    //-------------------------- AUTOGENERATED END --------------------------
}
